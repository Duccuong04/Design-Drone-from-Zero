/*
 * IMU9DOF.h
 *
 *  Created on: Aug 15, 2025
 *      Author: Nguyen Duc Cuong
 */

#ifndef INC_IMU9DOF_H_
#define INC_IMU9DOF_H_

#include "stdio.h"
#include "main.h"
#include "flash.h"
#include "math.h"

//#define USE_HAL_I2C_REGISTER_CALLBACKS  1

/*
 * @brief	Enum trả về trạng thái các hàm
 */
typedef enum  {
	IMU9DOF_Result_Ok = 0x00,
	IMU9DOF_Result_Error,
	IMU9DOF_Result_DeviceNotConnected, // Thiết bị không được kết nối đến
	IMU9DOF_Result_DeviceInvalid,       // Không phải địa chỉ của mpu6050
	IMU9DFO_Result_MPU6050_NotConnected,
	IMU9DFO_Result_HMC5883L_NotConnected
} IMU9DOF_Result;


/*
 * @brief	Độ phân giải Acc, Gyro của MPU6050
 * Dùng để cấu hình thang đo (full-scale range) của Acc và Gyro.
 * Sau khi chọn, giá trị đọc thô (raw) sẽ cần nhân với hệ số accelMult, gyroMult để đổi sang m/s² hoặc deg/s.
 */
typedef enum  {
	MPU6050_Accelerometer_2G = 0x00,
	MPU6050_Accelerometer_4G = 0x01,
	MPU6050_Accelerometer_8G = 0x02,
	MPU6050_Accelerometer_16G = 0x03
} MPU6050_Accelerometer;

typedef enum {
	MPU6050_Gyroscope_250s = 0x00,
	MPU6050_Gyroscope_500s = 0x01,
	MPU6050_Gyroscope_1000s = 0x02,
	MPU6050_Gyroscope_2000s = 0x03
} MPU6050_Gyroscope;


/*
 * @brief	Xác định khoảng đo của từ trường.
 * Tương ứng với LSB/Gauss để tính độ lớn từ trường thực tế.
 */
typedef enum
{
    HMC5883L_RANGE_8_1GA     = 0b111,
    HMC5883L_RANGE_5_6GA     = 0b110,
    HMC5883L_RANGE_4_7GA     = 0b101,
    HMC5883L_RANGE_4GA       = 0b100,
    HMC5883L_RANGE_2_5GA     = 0b011,
    HMC5883L_RANGE_1_9GA     = 0b010,
    HMC5883L_RANGE_1_3GA     = 0b001,
    HMC5883L_RANGE_0_88GA    = 0b000
} HMC5883l_range;

/*
 * @brief	Struct dữ liệu thô của cảm biến
 * Chứa giá trị raw + hệ số chuyển đổi sang đơn vị vật lý (m/s²).
 * Ngoài raw data, có thêm các thành phần để lưu tích hợp/điều khiển roll, pitch, yaw.
 * Chứa giá trị raw từ HMC5883L và hệ số chuyển đổi ra milliGauss
 */
typedef struct Acceleromoter_t{
	int16_t x;
	int16_t y;
	int16_t z;
	float accelMult;
}Accelerometer;

typedef struct Gyrometer_t {
	int16_t x;
	int16_t y;
	int16_t z;
	float rollInput;
	float pitchInput;
	float yawInput;
	float gyroMult;
} Gyrometer;

typedef struct Magnetometer_t {
	int16_t x;
	int16_t y;
	int16_t z;
	float mgausPerDigit;
} Magnetometer;

/*
 * @brief	Enum OSR của MS5611
 * OSR = Over Sampling Rate (ảnh hưởng đến độ chính xác và tốc độ đọc dữ liệu).
 */
typedef enum
{
    MS5611_OSR_4096   = 0x08,
    MS5611_OSR_2048   = 0x06,
    MS5611_OSR_1024   = 0x04,
    MS5611_OSR_512    = 0x02,
    MS5611_OSR_256    = 0x00
} ms5611_osr;

/*
 * @brief	Class IMU9DOF
 * Chứa các kiểu dữ liệu và hàm giao tiếp với GY 86
 */
class IMU9DOF{
public:

	/*
	 * Bật/tắt chế độ khóa hướng (heading lock).
	 * Khi bật → hệ thống sẽ giữ hướng theo một giá trị tham chiếu (courseLockHeading), ngay cả khi drone quay.
	 */
	bool headingLock;

	/*
	 * Lưu hướng (heading) tham chiếu ban đầu khi kích hoạt heading lock.
	 * Khi drone đang hướng Bắc (0°) và bật heading lock → biến này lưu 0°.
	 * Sau đó nếu drone xoay về hướng Đông (90°) nhưng người điều khiển đẩy joystick "tiến lên", drone vẫn bay theo hướng Bắc ban đầu.
	 */
	float courseLockHeading;

	/*
	 * Tọa độ từ trường đã chiếu lên mặt phẳng ngang (sau khi loại bỏ thành phần nghiêng do roll/pitch).
	 */
	float compassHorizontal_X;
	float compassHorizontal_Y;

	/*
	 * Đây là góc hướng thực tế (heading angle) tính theo la bàn (compass).
	 * Đơn vị thường là độ (0°–360°) hoặc rad.
	 */
	float actualCompassHeading;

	/*
	 * Độ lệch từ (magnetic declination) giữa Bắc từ (magnet) và Bắc thực (true north).
	 * Giá trị này phụ thuộc vị trí địa lý (ở VN ~0.5°–1°).
	 * Dùng để hiệu chỉnh heading
	 */
	float declination;

	/*
	 * Giá trị nhiệt độ raw từ cảm biến MPU6050.
	 * Chủ yếu dùng để theo dõi hoặc bù trôi gyro theo nhiệt độ.
	 */
	int16_t temp;

	/*
	 * Struct chứa dữ liệu la bàn (HMC5883L)
	 */
	Magnetometer magn;

	/*
	 * Struct chứa dữ liệu gia tốc (MPU6050)
	 */
	Accelerometer accel;

	/*
	* Struct chứa dữ liệu Gyro
	*/
	Gyrometer gyro;

	/*
	 * Dùng để bù offset của cảm biến.
	 * accPitchCalValue, accRollCalValue: hiệu chỉnh góc tính từ accelerometer khi sensor không hoàn toàn ngang bằng.
	 * gyroRollCalValue, gyroPitchCalValue, gyroYawCalValue: offset gyro khi đặt IMU yên tĩnh (dùng trong hàm CalibGyro()).
	 */
	int16_t accPitchCalValue;
	int16_t accRollCalValue;
	int32_t gyroRollCalValue;
	int32_t gyroPitchCalValue;
	int32_t gyroYawCalValue;

	/*
	 * Kết quả cuối cùng của hệ thống sau khi fuse dữ liệu từ Gyro + Acc + Compass.
	 * angleRoll (°): góc lăn sang trái/phải (nghiêng cánh máy bay).
	 * anglePitch (°): góc chúc/ngẩng đầu.
	 * angleYaw (°): góc quay quanh trục thẳng đứng (heading).
	 */
	float angleRoll;
	float anglePitch;
	float angleYaw;

	I2C_HandleTypeDef *hi2c;

	/*
	 * Mảng giá trị Calibration
	 * index 0 - pitch
	 * index 1 - roll
	 */
	int32_t accelCalValue[2];

	/*
	 * Moving average filter để làm mượt dữ liệu Z-axis.
	 * shortAverageAccel_Z[25]: bộ nhớ ngắn hạn (25 mẫu). → phản ứng nhanh
	 * longAverageAccel_Z[50]: bộ nhớ dài hạn (50 mẫu). → lọc nhiễu tốt hơn.
	 * con trỏ vòng (circular buffer index).
	 * tổng giá trị, dùng để tính giá trị trung bình nhanh mà không phải cộng dồn lại toàn bộ mỗi lần.
	 */
	uint8_t indexShortAverageRotatingMem, indexLongAverageRotatingMem;
	int16_t shortAverageAccel_Z[25];
	int16_t longAverageAccel_Z[50];
	int32_t shortTotalAccel_Z;
	int32_t longTotalAccel_Z;

	/*
	 * Tính toán giá trị trung bình & vector gia tốc
	 * accelAverageTotal: giá trị gia tốc trung bình sau khi lọc.
	 * accelTotalVector: độ lớn vector gia tốc (√(x² + y² + z²)), thường gần 1g khi đứng yên.
	 * accelTotalVectorAtStart: giá trị vector ban đầu (dùng để so sánh, hiệu chỉnh offset hoặc phát hiện thay đổi).
	 */
	int32_t accelAverageTotal;
	int32_t accelTotalVector;
	int32_t accelTotalVectorAtStart;

	/*
	 * Tích hợp gia tốc theo phương thẳng đứng
	 * Gia tốc Z tích hợp theo thời gian → liên quan đến tính thay đổi độ cao.
	 * Tuy nhiên tích hợp 2 lần (gia tốc → vận tốc → độ cao) sẽ bị trôi, nên thường chỉ dùng như tín hiệu bổ trợ, kết hợp với barometer (MS5611).
	 */
	int32_t accelAltIntegrated;

	/*
	 * Bù nghiêng cho PID
	 * Giá trị bù pitch và roll để giữ drone/robot cân bằng.
	   Ví dụ: nếu accelerometer cho thấy drone nghiêng sang trái → rollLevelAdjust khác 0 → PID controller sẽ sinh lệnh bù để cân bằng lại.
	 */
	float pitchLevelAdjust, rollLevelAdjust;

	/*
	 * Góc Roll, Pitch tính chỉ từ Accelerometer.
	 */
	float angleRollAccel, anglePitchAccel;

	/*
	 * Constructor function Nhận I2C_HandleTypeDef* (cấu hình I2C của STM32) + thông tin Flash (sector, address) để lưu giá trị hiệu chuẩn.
	 */
	IMU9DOF(I2C_HandleTypeDef * theI2c, uint8_t theSector, uint32_t theAddrs);

	/*
	 * Đọc dữ liệu raw từ MPU6050 (Gyro + Accel).
	 */
	void ReadGyroAccel();

	float CourseDeviation(float theValue1, float theValue2);

	void ReadAngleRPY();
	void CalculateGyroInput();
	void CalibGyro();
	void CalibCompass();
	void CalibLevel(uint8_t* theError);
	void VerticalAccelerationCalculations();
	IMU9DOF_Result ReadRawAllParameter();
	IMU9DOF_Result IsReadyToInterface();

	HAL_StatusTypeDef Init();
	HAL_StatusTypeDef SetupCompass();
	HAL_StatusTypeDef SetupGyro();
	HAL_StatusTypeDef SetupAutomaticReadCompass();

	HAL_StatusTypeDef SetGyroSensitivityMPU6050(MPU6050_Gyroscope theGyroSens);
	HAL_StatusTypeDef SetAccelSensitivityMPU6050(MPU6050_Accelerometer theAccelSens);
	HAL_StatusTypeDef SetMagnSensitivityHMC5883L(HMC5883l_range theMagnSens);
	IMU9DOF_Result ReadCompass();
	IMU9DOF_Result IsReadyToInterfaceHMC5883L();
	IMU9DOF_Result IsReadyToInterfaceMPU6050();

	void setLevelAdjust(uint8_t theRateRoll, uint8_t theRatePitch);
private:
	int16_t IsAlreadyCalibGyro;
	bool isAlreadyCalibCompass;
	bool isOnLevelCalib;

	int16_t compassOffset_X, compassOffset_Y, compassOffset_Z;
	float compassScaleY, compassScaleZ;

	uint8_t sectorFlash;
	uint32_t addrsFlash;
	int16_t dataFlash[6];
};

#endif /* INC_IMU9DOF_H_ */
